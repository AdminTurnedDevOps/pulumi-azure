// *** WARNING: this file was generated by the Lumi Terraform Bridge (TFGEN) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as lumi from "@lumi/lumi";
import * as lumirt from "@lumi/lumirt";

export class VirtualMachine extends lumi.NamedResource implements VirtualMachineArgs {
    public readonly availabilitySetId: string;
    public readonly bootDiagnostics?: { enabled: boolean, storageUri: string }[];
    public readonly deleteDataDisksOnTermination?: boolean;
    public readonly deleteOsDiskOnTermination?: boolean;
    public readonly diagnosticsProfile?: { bootDiagnostics: { enabled: boolean, storageUri: string }[] }[];
    public readonly licenseType: string;
    public readonly location: string;
    public readonly virtualMachineName?: string;
    public readonly networkInterfaceIds: string[];
    public readonly osProfile?: { adminPassword: string, adminUsername: string, computerName: string, customData: string }[];
    public readonly osProfileLinuxConfig?: { disablePasswordAuthentication: boolean, sshKeys?: { keyData?: string, path: string }[] }[];
    public readonly osProfileSecrets?: { sourceVaultId: string, vaultCertificates?: { certificateStore?: string, certificateUrl: string }[] }[];
    public readonly osProfileWindowsConfig?: { additionalUnattendConfig?: { component: string, content: string, pass: string, settingName: string }[], enableAutomaticUpgrades?: boolean, provisionVmAgent?: boolean, winrm?: { certificateUrl?: string, protocol: string }[] }[];
    public readonly plan?: { name: string, product: string, publisher: string }[];
    public readonly primaryNetworkInterfaceId?: string;
    public readonly resourceGroupName: string;
    public readonly storageDataDisk?: { caching: string, createOption: string, diskSizeGb: number, lun: number, managedDiskId: string, managedDiskType: string, name: string, vhdUri?: string }[];
    public readonly storageImageReference: { offer: string, publisher: string, sku: string, version: string }[];
    public readonly storageOsDisk: { caching: string, createOption: string, diskSizeGb?: number, imageUri?: string, managedDiskId: string, managedDiskType: string, name: string, osType?: string, vhdUri?: string }[];
    public readonly tags: {[key: string]: any};
    public readonly vmSize: string;

    constructor(name: string, args: VirtualMachineArgs) {
        super(name);
        this.availabilitySetId = args.availabilitySetId;
        this.bootDiagnostics = args.bootDiagnostics;
        this.deleteDataDisksOnTermination = args.deleteDataDisksOnTermination;
        this.deleteOsDiskOnTermination = args.deleteOsDiskOnTermination;
        this.diagnosticsProfile = args.diagnosticsProfile;
        this.licenseType = args.licenseType;
        if (lumirt.defaultIfComputed(args.location, "") === undefined) {
            throw new Error("Property argument 'location' is required, but was missing");
        }
        this.location = args.location;
        this.virtualMachineName = args.virtualMachineName;
        if (lumirt.defaultIfComputed(args.networkInterfaceIds, "") === undefined) {
            throw new Error("Property argument 'networkInterfaceIds' is required, but was missing");
        }
        this.networkInterfaceIds = args.networkInterfaceIds;
        this.osProfile = args.osProfile;
        this.osProfileLinuxConfig = args.osProfileLinuxConfig;
        this.osProfileSecrets = args.osProfileSecrets;
        this.osProfileWindowsConfig = args.osProfileWindowsConfig;
        this.plan = args.plan;
        this.primaryNetworkInterfaceId = args.primaryNetworkInterfaceId;
        if (lumirt.defaultIfComputed(args.resourceGroupName, "") === undefined) {
            throw new Error("Property argument 'resourceGroupName' is required, but was missing");
        }
        this.resourceGroupName = args.resourceGroupName;
        this.storageDataDisk = args.storageDataDisk;
        this.storageImageReference = args.storageImageReference;
        if (lumirt.defaultIfComputed(args.storageOsDisk, "") === undefined) {
            throw new Error("Property argument 'storageOsDisk' is required, but was missing");
        }
        this.storageOsDisk = args.storageOsDisk;
        this.tags = args.tags;
        if (lumirt.defaultIfComputed(args.vmSize, "") === undefined) {
            throw new Error("Property argument 'vmSize' is required, but was missing");
        }
        this.vmSize = args.vmSize;
    }
}

export interface VirtualMachineArgs {
    readonly availabilitySetId?: string;
    readonly bootDiagnostics?: { enabled: boolean, storageUri: string }[];
    readonly deleteDataDisksOnTermination?: boolean;
    readonly deleteOsDiskOnTermination?: boolean;
    readonly diagnosticsProfile?: { bootDiagnostics: { enabled: boolean, storageUri: string }[] }[];
    readonly licenseType?: string;
    readonly location: string;
    readonly virtualMachineName?: string;
    readonly networkInterfaceIds: string[];
    readonly osProfile?: { adminPassword: string, adminUsername: string, computerName: string, customData: string }[];
    readonly osProfileLinuxConfig?: { disablePasswordAuthentication: boolean, sshKeys?: { keyData?: string, path: string }[] }[];
    readonly osProfileSecrets?: { sourceVaultId: string, vaultCertificates?: { certificateStore?: string, certificateUrl: string }[] }[];
    readonly osProfileWindowsConfig?: { additionalUnattendConfig?: { component: string, content: string, pass: string, settingName: string }[], enableAutomaticUpgrades?: boolean, provisionVmAgent?: boolean, winrm?: { certificateUrl?: string, protocol: string }[] }[];
    readonly plan?: { name: string, product: string, publisher: string }[];
    readonly primaryNetworkInterfaceId?: string;
    readonly resourceGroupName: string;
    readonly storageDataDisk?: { caching: string, createOption: string, diskSizeGb: number, lun: number, managedDiskId: string, managedDiskType: string, name: string, vhdUri?: string }[];
    readonly storageImageReference?: { offer: string, publisher: string, sku: string, version: string }[];
    readonly storageOsDisk: { caching: string, createOption: string, diskSizeGb?: number, imageUri?: string, managedDiskId: string, managedDiskType: string, name: string, osType?: string, vhdUri?: string }[];
    readonly tags?: {[key: string]: any};
    readonly vmSize: string;
}

