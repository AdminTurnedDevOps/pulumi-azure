// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package redis

import (
	"context"
	"reflect"
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Manages a Redis Cache.
// 
// ## Default Redis Configuration Values
// 
// | Redis Value                     | Basic        | Standard     | Premium      |
// | ------------------------------- | ------------ | ------------ | ------------ |
// | enableAuthentication           | true         | true         | true         |
// | maxmemoryReserved              | 2            | 50           | 200          |
// | maxfragmentationmemoryReserved | 2            | 50           | 200          |
// | maxmemoryDelta                 | 2            | 50           | 200          |
// | maxmemoryPolicy                | volatile-lru | volatile-lru | volatile-lru |
// 
// > **NOTE:** The `maxmemoryReserved`, `maxmemoryDelta` and `maxfragmentationmemory-reserved` settings are only available for Standard and Premium caches. More details are available in the Relevant Links section below._
// 
// ---
// 
// A `patchSchedule` block supports the following:
// 
// * `dayOfWeek` (Required) the Weekday name - possible values include `Monday`, `Tuesday`, `Wednesday` etc.
// 
// * `startHourUtc` - (Optional) the Start Hour for maintenance in UTC - possible values range from `0 - 23`.
// 
// > **Note:** The Patch Window lasts for `5` hours from the `startHourUtc`.
// 
// ## Relevant Links
// 
//  - [Azure Redis Cache: SKU specific configuration limitations](https://azure.microsoft.com/en-us/documentation/articles/cache-configure/#advanced-settings)
//  - [Redis: Available Configuration Settings](http://redis.io/topics/config)
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/website/docs/r/redis_cache.html.markdown.
type Cache struct {
	pulumi.CustomResourceState

	// The size of the Redis cache to deploy. Valid values for a SKU `family` of C (Basic/Standard) are `0, 1, 2, 3, 4, 5, 6`, and for P (Premium) `family` are `1, 2, 3, 4`.
	Capacity pulumi.IntOutput `pulumi:"capacity"`

	// Enable the non-SSL port (6379) - disabled by default.
	EnableNonSslPort pulumi.BoolOutput `pulumi:"enableNonSslPort"`

	// The SKU family/pricing group to use. Valid values are `C` (for Basic/Standard SKU family) and `P` (for `Premium`)
	Family pulumi.StringOutput `pulumi:"family"`

	// The Hostname of the Redis Instance
	Hostname pulumi.StringOutput `pulumi:"hostname"`

	// The location of the resource group.
	Location pulumi.StringOutput `pulumi:"location"`

	// The minimum TLS version.  Defaults to `1.0`.
	MinimumTlsVersion pulumi.StringOutput `pulumi:"minimumTlsVersion"`

	// The name of the Redis instance. Changing this forces a
	// new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`

	// A list of `patchSchedule` blocks as defined below - only available for Premium SKU's.
	PatchSchedules CachePatchSchedulesArrayOutput `pulumi:"patchSchedules"`

	// The non-SSL Port of the Redis Instance
	Port pulumi.IntOutput `pulumi:"port"`

	// The Primary Access Key for the Redis Instance
	PrimaryAccessKey pulumi.StringOutput `pulumi:"primaryAccessKey"`

	// The Static IP Address to assign to the Redis Cache when hosted inside the Virtual Network. Changing this forces a new resource to be created.
	PrivateStaticIpAddress pulumi.StringOutput `pulumi:"privateStaticIpAddress"`

	// A `redisConfiguration` as defined below - with some limitations by SKU - defaults/details are shown below.
	RedisConfiguration CacheRedisConfigurationOutput `pulumi:"redisConfiguration"`

	// The name of the resource group in which to
	// create the Redis instance.
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`

	// The Secondary Access Key for the Redis Instance
	SecondaryAccessKey pulumi.StringOutput `pulumi:"secondaryAccessKey"`

	// *Only available when using the Premium SKU* The number of Shards to create on the Redis Cluster.
	ShardCount pulumi.IntOutput `pulumi:"shardCount"`

	// The SKU of Redis to use. Possible values are `Basic`, `Standard` and `Premium`.
	SkuName pulumi.StringOutput `pulumi:"skuName"`

	// The SSL Port of the Redis Instance
	SslPort pulumi.IntOutput `pulumi:"sslPort"`

	// *Only available when using the Premium SKU* The ID of the Subnet within which the Redis Cache should be deployed. This Subnet must only contain Azure Cache for Redis instances without any other type of resources. Changing this forces a new resource to be created.
	SubnetId pulumi.StringOutput `pulumi:"subnetId"`

	// A mapping of tags to assign to the resource.
	Tags pulumi.MapOutput `pulumi:"tags"`

	// A list of a single item of the Availability Zone which the Redis Cache should be allocated in.
	Zones pulumi.StringOutput `pulumi:"zones"`
}

// NewCache registers a new resource with the given unique name, arguments, and options.
func NewCache(ctx *pulumi.Context,
	name string, args *CacheArgs, opts ...pulumi.ResourceOption) (*Cache, error) {
	if args == nil || args.Capacity == nil {
		return nil, errors.New("missing required argument 'Capacity'")
	}
	if args == nil || args.Family == nil {
		return nil, errors.New("missing required argument 'Family'")
	}
	if args == nil || args.ResourceGroupName == nil {
		return nil, errors.New("missing required argument 'ResourceGroupName'")
	}
	if args == nil || args.SkuName == nil {
		return nil, errors.New("missing required argument 'SkuName'")
	}
	inputs := map[string]pulumi.Input{}
	if args != nil {
		if i := args.Capacity; i != nil { inputs["capacity"] = i.ToIntOutput() }
		if i := args.EnableNonSslPort; i != nil { inputs["enableNonSslPort"] = i.ToBoolOutput() }
		if i := args.Family; i != nil { inputs["family"] = i.ToStringOutput() }
		if i := args.Location; i != nil { inputs["location"] = i.ToStringOutput() }
		if i := args.MinimumTlsVersion; i != nil { inputs["minimumTlsVersion"] = i.ToStringOutput() }
		if i := args.Name; i != nil { inputs["name"] = i.ToStringOutput() }
		if i := args.PatchSchedules; i != nil { inputs["patchSchedules"] = i.ToCachePatchSchedulesArrayOutput() }
		if i := args.PrivateStaticIpAddress; i != nil { inputs["privateStaticIpAddress"] = i.ToStringOutput() }
		if i := args.RedisConfiguration; i != nil { inputs["redisConfiguration"] = i.ToCacheRedisConfigurationOutput() }
		if i := args.ResourceGroupName; i != nil { inputs["resourceGroupName"] = i.ToStringOutput() }
		if i := args.ShardCount; i != nil { inputs["shardCount"] = i.ToIntOutput() }
		if i := args.SkuName; i != nil { inputs["skuName"] = i.ToStringOutput() }
		if i := args.SubnetId; i != nil { inputs["subnetId"] = i.ToStringOutput() }
		if i := args.Tags; i != nil { inputs["tags"] = i.ToMapOutput() }
		if i := args.Zones; i != nil { inputs["zones"] = i.ToStringOutput() }
	}
	var resource Cache
	err := ctx.RegisterResource("azure:redis/cache:Cache", name, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCache gets an existing Cache resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCache(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CacheState, opts ...pulumi.ResourceOption) (*Cache, error) {
	inputs := map[string]pulumi.Input{}
	if state != nil {
		if i := state.Capacity; i != nil { inputs["capacity"] = i.ToIntOutput() }
		if i := state.EnableNonSslPort; i != nil { inputs["enableNonSslPort"] = i.ToBoolOutput() }
		if i := state.Family; i != nil { inputs["family"] = i.ToStringOutput() }
		if i := state.Hostname; i != nil { inputs["hostname"] = i.ToStringOutput() }
		if i := state.Location; i != nil { inputs["location"] = i.ToStringOutput() }
		if i := state.MinimumTlsVersion; i != nil { inputs["minimumTlsVersion"] = i.ToStringOutput() }
		if i := state.Name; i != nil { inputs["name"] = i.ToStringOutput() }
		if i := state.PatchSchedules; i != nil { inputs["patchSchedules"] = i.ToCachePatchSchedulesArrayOutput() }
		if i := state.Port; i != nil { inputs["port"] = i.ToIntOutput() }
		if i := state.PrimaryAccessKey; i != nil { inputs["primaryAccessKey"] = i.ToStringOutput() }
		if i := state.PrivateStaticIpAddress; i != nil { inputs["privateStaticIpAddress"] = i.ToStringOutput() }
		if i := state.RedisConfiguration; i != nil { inputs["redisConfiguration"] = i.ToCacheRedisConfigurationOutput() }
		if i := state.ResourceGroupName; i != nil { inputs["resourceGroupName"] = i.ToStringOutput() }
		if i := state.SecondaryAccessKey; i != nil { inputs["secondaryAccessKey"] = i.ToStringOutput() }
		if i := state.ShardCount; i != nil { inputs["shardCount"] = i.ToIntOutput() }
		if i := state.SkuName; i != nil { inputs["skuName"] = i.ToStringOutput() }
		if i := state.SslPort; i != nil { inputs["sslPort"] = i.ToIntOutput() }
		if i := state.SubnetId; i != nil { inputs["subnetId"] = i.ToStringOutput() }
		if i := state.Tags; i != nil { inputs["tags"] = i.ToMapOutput() }
		if i := state.Zones; i != nil { inputs["zones"] = i.ToStringOutput() }
	}
	var resource Cache
	err := ctx.ReadResource("azure:redis/cache:Cache", name, id, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Cache resources.
type CacheState struct {
	// The size of the Redis cache to deploy. Valid values for a SKU `family` of C (Basic/Standard) are `0, 1, 2, 3, 4, 5, 6`, and for P (Premium) `family` are `1, 2, 3, 4`.
	Capacity pulumi.IntInput `pulumi:"capacity"`
	// Enable the non-SSL port (6379) - disabled by default.
	EnableNonSslPort pulumi.BoolInput `pulumi:"enableNonSslPort"`
	// The SKU family/pricing group to use. Valid values are `C` (for Basic/Standard SKU family) and `P` (for `Premium`)
	Family pulumi.StringInput `pulumi:"family"`
	// The Hostname of the Redis Instance
	Hostname pulumi.StringInput `pulumi:"hostname"`
	// The location of the resource group.
	Location pulumi.StringInput `pulumi:"location"`
	// The minimum TLS version.  Defaults to `1.0`.
	MinimumTlsVersion pulumi.StringInput `pulumi:"minimumTlsVersion"`
	// The name of the Redis instance. Changing this forces a
	// new resource to be created.
	Name pulumi.StringInput `pulumi:"name"`
	// A list of `patchSchedule` blocks as defined below - only available for Premium SKU's.
	PatchSchedules CachePatchSchedulesArrayInput `pulumi:"patchSchedules"`
	// The non-SSL Port of the Redis Instance
	Port pulumi.IntInput `pulumi:"port"`
	// The Primary Access Key for the Redis Instance
	PrimaryAccessKey pulumi.StringInput `pulumi:"primaryAccessKey"`
	// The Static IP Address to assign to the Redis Cache when hosted inside the Virtual Network. Changing this forces a new resource to be created.
	PrivateStaticIpAddress pulumi.StringInput `pulumi:"privateStaticIpAddress"`
	// A `redisConfiguration` as defined below - with some limitations by SKU - defaults/details are shown below.
	RedisConfiguration CacheRedisConfigurationInput `pulumi:"redisConfiguration"`
	// The name of the resource group in which to
	// create the Redis instance.
	ResourceGroupName pulumi.StringInput `pulumi:"resourceGroupName"`
	// The Secondary Access Key for the Redis Instance
	SecondaryAccessKey pulumi.StringInput `pulumi:"secondaryAccessKey"`
	// *Only available when using the Premium SKU* The number of Shards to create on the Redis Cluster.
	ShardCount pulumi.IntInput `pulumi:"shardCount"`
	// The SKU of Redis to use. Possible values are `Basic`, `Standard` and `Premium`.
	SkuName pulumi.StringInput `pulumi:"skuName"`
	// The SSL Port of the Redis Instance
	SslPort pulumi.IntInput `pulumi:"sslPort"`
	// *Only available when using the Premium SKU* The ID of the Subnet within which the Redis Cache should be deployed. This Subnet must only contain Azure Cache for Redis instances without any other type of resources. Changing this forces a new resource to be created.
	SubnetId pulumi.StringInput `pulumi:"subnetId"`
	// A mapping of tags to assign to the resource.
	Tags pulumi.MapInput `pulumi:"tags"`
	// A list of a single item of the Availability Zone which the Redis Cache should be allocated in.
	Zones pulumi.StringInput `pulumi:"zones"`
}

// The set of arguments for constructing a Cache resource.
type CacheArgs struct {
	// The size of the Redis cache to deploy. Valid values for a SKU `family` of C (Basic/Standard) are `0, 1, 2, 3, 4, 5, 6`, and for P (Premium) `family` are `1, 2, 3, 4`.
	Capacity pulumi.IntInput `pulumi:"capacity"`
	// Enable the non-SSL port (6379) - disabled by default.
	EnableNonSslPort pulumi.BoolInput `pulumi:"enableNonSslPort"`
	// The SKU family/pricing group to use. Valid values are `C` (for Basic/Standard SKU family) and `P` (for `Premium`)
	Family pulumi.StringInput `pulumi:"family"`
	// The location of the resource group.
	Location pulumi.StringInput `pulumi:"location"`
	// The minimum TLS version.  Defaults to `1.0`.
	MinimumTlsVersion pulumi.StringInput `pulumi:"minimumTlsVersion"`
	// The name of the Redis instance. Changing this forces a
	// new resource to be created.
	Name pulumi.StringInput `pulumi:"name"`
	// A list of `patchSchedule` blocks as defined below - only available for Premium SKU's.
	PatchSchedules CachePatchSchedulesArrayInput `pulumi:"patchSchedules"`
	// The Static IP Address to assign to the Redis Cache when hosted inside the Virtual Network. Changing this forces a new resource to be created.
	PrivateStaticIpAddress pulumi.StringInput `pulumi:"privateStaticIpAddress"`
	// A `redisConfiguration` as defined below - with some limitations by SKU - defaults/details are shown below.
	RedisConfiguration CacheRedisConfigurationInput `pulumi:"redisConfiguration"`
	// The name of the resource group in which to
	// create the Redis instance.
	ResourceGroupName pulumi.StringInput `pulumi:"resourceGroupName"`
	// *Only available when using the Premium SKU* The number of Shards to create on the Redis Cluster.
	ShardCount pulumi.IntInput `pulumi:"shardCount"`
	// The SKU of Redis to use. Possible values are `Basic`, `Standard` and `Premium`.
	SkuName pulumi.StringInput `pulumi:"skuName"`
	// *Only available when using the Premium SKU* The ID of the Subnet within which the Redis Cache should be deployed. This Subnet must only contain Azure Cache for Redis instances without any other type of resources. Changing this forces a new resource to be created.
	SubnetId pulumi.StringInput `pulumi:"subnetId"`
	// A mapping of tags to assign to the resource.
	Tags pulumi.MapInput `pulumi:"tags"`
	// A list of a single item of the Availability Zone which the Redis Cache should be allocated in.
	Zones pulumi.StringInput `pulumi:"zones"`
}
type CachePatchSchedules struct {
	DayOfWeek string `pulumi:"dayOfWeek"`
	StartHourUtc *int `pulumi:"startHourUtc"`
}
var cachePatchSchedulesType = reflect.TypeOf((*CachePatchSchedules)(nil)).Elem()

type CachePatchSchedulesInput interface {
	pulumi.Input

	ToCachePatchSchedulesOutput() CachePatchSchedulesOutput
	ToCachePatchSchedulesOutputWithContext(ctx context.Context) CachePatchSchedulesOutput
}

type CachePatchSchedulesArgs struct {
	DayOfWeek pulumi.StringInput `pulumi:"dayOfWeek"`
	StartHourUtc pulumi.IntInput `pulumi:"startHourUtc"`
}

func (CachePatchSchedulesArgs) ElementType() reflect.Type {
	return cachePatchSchedulesType
}

func (a CachePatchSchedulesArgs) ToCachePatchSchedulesOutput() CachePatchSchedulesOutput {
	return pulumi.ToOutput(a).(CachePatchSchedulesOutput)
}

func (a CachePatchSchedulesArgs) ToCachePatchSchedulesOutputWithContext(ctx context.Context) CachePatchSchedulesOutput {
	return pulumi.ToOutputWithContext(ctx, a).(CachePatchSchedulesOutput)
}

type CachePatchSchedulesOutput struct { *pulumi.OutputState }

func (o CachePatchSchedulesOutput) DayOfWeek() pulumi.StringOutput {
	return o.Apply(func(v CachePatchSchedules) string {
		return v.DayOfWeek
	}).(pulumi.StringOutput)
}

func (o CachePatchSchedulesOutput) StartHourUtc() pulumi.IntOutput {
	return o.Apply(func(v CachePatchSchedules) int {
		if v.StartHourUtc == nil { return *new(int) } else { return *v.StartHourUtc }
	}).(pulumi.IntOutput)
}

func (CachePatchSchedulesOutput) ElementType() reflect.Type {
	return cachePatchSchedulesType
}

func (o CachePatchSchedulesOutput) ToCachePatchSchedulesOutput() CachePatchSchedulesOutput {
	return o
}

func (o CachePatchSchedulesOutput) ToCachePatchSchedulesOutputWithContext(ctx context.Context) CachePatchSchedulesOutput {
	return o
}

func init() { pulumi.RegisterOutputType(CachePatchSchedulesOutput{}) }

var cachePatchSchedulesArrayType = reflect.TypeOf((*[]CachePatchSchedules)(nil)).Elem()

type CachePatchSchedulesArrayInput interface {
	pulumi.Input

	ToCachePatchSchedulesArrayOutput() CachePatchSchedulesArrayOutput
	ToCachePatchSchedulesArrayOutputWithContext(ctx context.Context) CachePatchSchedulesArrayOutput
}

type CachePatchSchedulesArrayArgs []CachePatchSchedulesInput

func (CachePatchSchedulesArrayArgs) ElementType() reflect.Type {
	return cachePatchSchedulesArrayType
}

func (a CachePatchSchedulesArrayArgs) ToCachePatchSchedulesArrayOutput() CachePatchSchedulesArrayOutput {
	return pulumi.ToOutput(a).(CachePatchSchedulesArrayOutput)
}

func (a CachePatchSchedulesArrayArgs) ToCachePatchSchedulesArrayOutputWithContext(ctx context.Context) CachePatchSchedulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, a).(CachePatchSchedulesArrayOutput)
}

type CachePatchSchedulesArrayOutput struct { *pulumi.OutputState }

func (o CachePatchSchedulesArrayOutput) Index(i pulumi.IntInput) CachePatchSchedulesOutput {
	return pulumi.All(o, i).Apply(func(vs []interface{}) CachePatchSchedules {
		return vs[0].([]CachePatchSchedules)[vs[1].(int)]
	}).(CachePatchSchedulesOutput)
}

func (CachePatchSchedulesArrayOutput) ElementType() reflect.Type {
	return cachePatchSchedulesArrayType
}

func (o CachePatchSchedulesArrayOutput) ToCachePatchSchedulesArrayOutput() CachePatchSchedulesArrayOutput {
	return o
}

func (o CachePatchSchedulesArrayOutput) ToCachePatchSchedulesArrayOutputWithContext(ctx context.Context) CachePatchSchedulesArrayOutput {
	return o
}

func init() { pulumi.RegisterOutputType(CachePatchSchedulesArrayOutput{}) }

type CacheRedisConfiguration struct {
	AofBackupEnabled *bool `pulumi:"aofBackupEnabled"`
	AofStorageConnectionString0 *string `pulumi:"aofStorageConnectionString0"`
	AofStorageConnectionString1 *string `pulumi:"aofStorageConnectionString1"`
	EnableAuthentication *bool `pulumi:"enableAuthentication"`
	// Returns the max number of connected clients at the same time.
	Maxclients *int `pulumi:"maxclients"`
	MaxfragmentationmemoryReserved *int `pulumi:"maxfragmentationmemoryReserved"`
	MaxmemoryDelta *int `pulumi:"maxmemoryDelta"`
	MaxmemoryPolicy *string `pulumi:"maxmemoryPolicy"`
	MaxmemoryReserved *int `pulumi:"maxmemoryReserved"`
	NotifyKeyspaceEvents *string `pulumi:"notifyKeyspaceEvents"`
	RdbBackupEnabled *bool `pulumi:"rdbBackupEnabled"`
	RdbBackupFrequency *int `pulumi:"rdbBackupFrequency"`
	RdbBackupMaxSnapshotCount *int `pulumi:"rdbBackupMaxSnapshotCount"`
	RdbStorageConnectionString *string `pulumi:"rdbStorageConnectionString"`
}
var cacheRedisConfigurationType = reflect.TypeOf((*CacheRedisConfiguration)(nil)).Elem()

type CacheRedisConfigurationInput interface {
	pulumi.Input

	ToCacheRedisConfigurationOutput() CacheRedisConfigurationOutput
	ToCacheRedisConfigurationOutputWithContext(ctx context.Context) CacheRedisConfigurationOutput
}

type CacheRedisConfigurationArgs struct {
	AofBackupEnabled pulumi.BoolInput `pulumi:"aofBackupEnabled"`
	AofStorageConnectionString0 pulumi.StringInput `pulumi:"aofStorageConnectionString0"`
	AofStorageConnectionString1 pulumi.StringInput `pulumi:"aofStorageConnectionString1"`
	EnableAuthentication pulumi.BoolInput `pulumi:"enableAuthentication"`
	// Returns the max number of connected clients at the same time.
	Maxclients pulumi.IntInput `pulumi:"maxclients"`
	MaxfragmentationmemoryReserved pulumi.IntInput `pulumi:"maxfragmentationmemoryReserved"`
	MaxmemoryDelta pulumi.IntInput `pulumi:"maxmemoryDelta"`
	MaxmemoryPolicy pulumi.StringInput `pulumi:"maxmemoryPolicy"`
	MaxmemoryReserved pulumi.IntInput `pulumi:"maxmemoryReserved"`
	NotifyKeyspaceEvents pulumi.StringInput `pulumi:"notifyKeyspaceEvents"`
	RdbBackupEnabled pulumi.BoolInput `pulumi:"rdbBackupEnabled"`
	RdbBackupFrequency pulumi.IntInput `pulumi:"rdbBackupFrequency"`
	RdbBackupMaxSnapshotCount pulumi.IntInput `pulumi:"rdbBackupMaxSnapshotCount"`
	RdbStorageConnectionString pulumi.StringInput `pulumi:"rdbStorageConnectionString"`
}

func (CacheRedisConfigurationArgs) ElementType() reflect.Type {
	return cacheRedisConfigurationType
}

func (a CacheRedisConfigurationArgs) ToCacheRedisConfigurationOutput() CacheRedisConfigurationOutput {
	return pulumi.ToOutput(a).(CacheRedisConfigurationOutput)
}

func (a CacheRedisConfigurationArgs) ToCacheRedisConfigurationOutputWithContext(ctx context.Context) CacheRedisConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, a).(CacheRedisConfigurationOutput)
}

type CacheRedisConfigurationOutput struct { *pulumi.OutputState }

func (o CacheRedisConfigurationOutput) AofBackupEnabled() pulumi.BoolOutput {
	return o.Apply(func(v CacheRedisConfiguration) bool {
		if v.AofBackupEnabled == nil { return *new(bool) } else { return *v.AofBackupEnabled }
	}).(pulumi.BoolOutput)
}

func (o CacheRedisConfigurationOutput) AofStorageConnectionString0() pulumi.StringOutput {
	return o.Apply(func(v CacheRedisConfiguration) string {
		if v.AofStorageConnectionString0 == nil { return *new(string) } else { return *v.AofStorageConnectionString0 }
	}).(pulumi.StringOutput)
}

func (o CacheRedisConfigurationOutput) AofStorageConnectionString1() pulumi.StringOutput {
	return o.Apply(func(v CacheRedisConfiguration) string {
		if v.AofStorageConnectionString1 == nil { return *new(string) } else { return *v.AofStorageConnectionString1 }
	}).(pulumi.StringOutput)
}

func (o CacheRedisConfigurationOutput) EnableAuthentication() pulumi.BoolOutput {
	return o.Apply(func(v CacheRedisConfiguration) bool {
		if v.EnableAuthentication == nil { return *new(bool) } else { return *v.EnableAuthentication }
	}).(pulumi.BoolOutput)
}

// Returns the max number of connected clients at the same time.
func (o CacheRedisConfigurationOutput) Maxclients() pulumi.IntOutput {
	return o.Apply(func(v CacheRedisConfiguration) int {
		if v.Maxclients == nil { return *new(int) } else { return *v.Maxclients }
	}).(pulumi.IntOutput)
}

func (o CacheRedisConfigurationOutput) MaxfragmentationmemoryReserved() pulumi.IntOutput {
	return o.Apply(func(v CacheRedisConfiguration) int {
		if v.MaxfragmentationmemoryReserved == nil { return *new(int) } else { return *v.MaxfragmentationmemoryReserved }
	}).(pulumi.IntOutput)
}

func (o CacheRedisConfigurationOutput) MaxmemoryDelta() pulumi.IntOutput {
	return o.Apply(func(v CacheRedisConfiguration) int {
		if v.MaxmemoryDelta == nil { return *new(int) } else { return *v.MaxmemoryDelta }
	}).(pulumi.IntOutput)
}

func (o CacheRedisConfigurationOutput) MaxmemoryPolicy() pulumi.StringOutput {
	return o.Apply(func(v CacheRedisConfiguration) string {
		if v.MaxmemoryPolicy == nil { return *new(string) } else { return *v.MaxmemoryPolicy }
	}).(pulumi.StringOutput)
}

func (o CacheRedisConfigurationOutput) MaxmemoryReserved() pulumi.IntOutput {
	return o.Apply(func(v CacheRedisConfiguration) int {
		if v.MaxmemoryReserved == nil { return *new(int) } else { return *v.MaxmemoryReserved }
	}).(pulumi.IntOutput)
}

func (o CacheRedisConfigurationOutput) NotifyKeyspaceEvents() pulumi.StringOutput {
	return o.Apply(func(v CacheRedisConfiguration) string {
		if v.NotifyKeyspaceEvents == nil { return *new(string) } else { return *v.NotifyKeyspaceEvents }
	}).(pulumi.StringOutput)
}

func (o CacheRedisConfigurationOutput) RdbBackupEnabled() pulumi.BoolOutput {
	return o.Apply(func(v CacheRedisConfiguration) bool {
		if v.RdbBackupEnabled == nil { return *new(bool) } else { return *v.RdbBackupEnabled }
	}).(pulumi.BoolOutput)
}

func (o CacheRedisConfigurationOutput) RdbBackupFrequency() pulumi.IntOutput {
	return o.Apply(func(v CacheRedisConfiguration) int {
		if v.RdbBackupFrequency == nil { return *new(int) } else { return *v.RdbBackupFrequency }
	}).(pulumi.IntOutput)
}

func (o CacheRedisConfigurationOutput) RdbBackupMaxSnapshotCount() pulumi.IntOutput {
	return o.Apply(func(v CacheRedisConfiguration) int {
		if v.RdbBackupMaxSnapshotCount == nil { return *new(int) } else { return *v.RdbBackupMaxSnapshotCount }
	}).(pulumi.IntOutput)
}

func (o CacheRedisConfigurationOutput) RdbStorageConnectionString() pulumi.StringOutput {
	return o.Apply(func(v CacheRedisConfiguration) string {
		if v.RdbStorageConnectionString == nil { return *new(string) } else { return *v.RdbStorageConnectionString }
	}).(pulumi.StringOutput)
}

func (CacheRedisConfigurationOutput) ElementType() reflect.Type {
	return cacheRedisConfigurationType
}

func (o CacheRedisConfigurationOutput) ToCacheRedisConfigurationOutput() CacheRedisConfigurationOutput {
	return o
}

func (o CacheRedisConfigurationOutput) ToCacheRedisConfigurationOutputWithContext(ctx context.Context) CacheRedisConfigurationOutput {
	return o
}

func init() { pulumi.RegisterOutputType(CacheRedisConfigurationOutput{}) }

