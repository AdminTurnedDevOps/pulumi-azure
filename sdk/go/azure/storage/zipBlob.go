// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package storage

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

type ZipBlob struct {
	pulumi.CustomResourceState

	AccessTier pulumi.StringOutput `pulumi:"accessTier"`

	Attempts pulumi.IntOutput `pulumi:"attempts"`

	ContentType pulumi.StringOutput `pulumi:"contentType"`

	Metadata pulumi.MapOutput `pulumi:"metadata"`

	Name pulumi.StringOutput `pulumi:"name"`

	Parallelism pulumi.IntOutput `pulumi:"parallelism"`

	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`

	Size pulumi.IntOutput `pulumi:"size"`

	Content pulumi.ArchiveOutput `pulumi:"content"`

	SourceContent pulumi.StringOutput `pulumi:"sourceContent"`

	SourceUri pulumi.StringOutput `pulumi:"sourceUri"`

	StorageAccountName pulumi.StringOutput `pulumi:"storageAccountName"`

	StorageContainerName pulumi.StringOutput `pulumi:"storageContainerName"`

	Type pulumi.StringOutput `pulumi:"type"`

	Url pulumi.StringOutput `pulumi:"url"`
}

// NewZipBlob registers a new resource with the given unique name, arguments, and options.
func NewZipBlob(ctx *pulumi.Context,
	name string, args *ZipBlobArgs, opts ...pulumi.ResourceOption) (*ZipBlob, error) {
	if args == nil || args.StorageAccountName == nil {
		return nil, errors.New("missing required argument 'StorageAccountName'")
	}
	if args == nil || args.StorageContainerName == nil {
		return nil, errors.New("missing required argument 'StorageContainerName'")
	}
	if args == nil || args.Type == nil {
		return nil, errors.New("missing required argument 'Type'")
	}
	inputs := map[string]pulumi.Input{}
	if args != nil {
		if i := args.AccessTier; i != nil { inputs["accessTier"] = i.ToStringOutput() }
		if i := args.Attempts; i != nil { inputs["attempts"] = i.ToIntOutput() }
		if i := args.ContentType; i != nil { inputs["contentType"] = i.ToStringOutput() }
		if i := args.Metadata; i != nil { inputs["metadata"] = i.ToMapOutput() }
		if i := args.Name; i != nil { inputs["name"] = i.ToStringOutput() }
		if i := args.Parallelism; i != nil { inputs["parallelism"] = i.ToIntOutput() }
		if i := args.ResourceGroupName; i != nil { inputs["resourceGroupName"] = i.ToStringOutput() }
		if i := args.Size; i != nil { inputs["size"] = i.ToIntOutput() }
		if i := args.Content; i != nil { inputs["content"] = i.ToArchiveOutput() }
		if i := args.SourceContent; i != nil { inputs["sourceContent"] = i.ToStringOutput() }
		if i := args.SourceUri; i != nil { inputs["sourceUri"] = i.ToStringOutput() }
		if i := args.StorageAccountName; i != nil { inputs["storageAccountName"] = i.ToStringOutput() }
		if i := args.StorageContainerName; i != nil { inputs["storageContainerName"] = i.ToStringOutput() }
		if i := args.Type; i != nil { inputs["type"] = i.ToStringOutput() }
	}
	var resource ZipBlob
	err := ctx.RegisterResource("azure:storage/zipBlob:ZipBlob", name, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetZipBlob gets an existing ZipBlob resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetZipBlob(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ZipBlobState, opts ...pulumi.ResourceOption) (*ZipBlob, error) {
	inputs := map[string]pulumi.Input{}
	if state != nil {
		if i := state.AccessTier; i != nil { inputs["accessTier"] = i.ToStringOutput() }
		if i := state.Attempts; i != nil { inputs["attempts"] = i.ToIntOutput() }
		if i := state.ContentType; i != nil { inputs["contentType"] = i.ToStringOutput() }
		if i := state.Metadata; i != nil { inputs["metadata"] = i.ToMapOutput() }
		if i := state.Name; i != nil { inputs["name"] = i.ToStringOutput() }
		if i := state.Parallelism; i != nil { inputs["parallelism"] = i.ToIntOutput() }
		if i := state.ResourceGroupName; i != nil { inputs["resourceGroupName"] = i.ToStringOutput() }
		if i := state.Size; i != nil { inputs["size"] = i.ToIntOutput() }
		if i := state.Content; i != nil { inputs["content"] = i.ToArchiveOutput() }
		if i := state.SourceContent; i != nil { inputs["sourceContent"] = i.ToStringOutput() }
		if i := state.SourceUri; i != nil { inputs["sourceUri"] = i.ToStringOutput() }
		if i := state.StorageAccountName; i != nil { inputs["storageAccountName"] = i.ToStringOutput() }
		if i := state.StorageContainerName; i != nil { inputs["storageContainerName"] = i.ToStringOutput() }
		if i := state.Type; i != nil { inputs["type"] = i.ToStringOutput() }
		if i := state.Url; i != nil { inputs["url"] = i.ToStringOutput() }
	}
	var resource ZipBlob
	err := ctx.ReadResource("azure:storage/zipBlob:ZipBlob", name, id, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ZipBlob resources.
type ZipBlobState struct {
	AccessTier pulumi.StringInput `pulumi:"accessTier"`
	Attempts pulumi.IntInput `pulumi:"attempts"`
	ContentType pulumi.StringInput `pulumi:"contentType"`
	Metadata pulumi.MapInput `pulumi:"metadata"`
	Name pulumi.StringInput `pulumi:"name"`
	Parallelism pulumi.IntInput `pulumi:"parallelism"`
	ResourceGroupName pulumi.StringInput `pulumi:"resourceGroupName"`
	Size pulumi.IntInput `pulumi:"size"`
	Content pulumi.ArchiveInput `pulumi:"content"`
	SourceContent pulumi.StringInput `pulumi:"sourceContent"`
	SourceUri pulumi.StringInput `pulumi:"sourceUri"`
	StorageAccountName pulumi.StringInput `pulumi:"storageAccountName"`
	StorageContainerName pulumi.StringInput `pulumi:"storageContainerName"`
	Type pulumi.StringInput `pulumi:"type"`
	Url pulumi.StringInput `pulumi:"url"`
}

// The set of arguments for constructing a ZipBlob resource.
type ZipBlobArgs struct {
	AccessTier pulumi.StringInput `pulumi:"accessTier"`
	Attempts pulumi.IntInput `pulumi:"attempts"`
	ContentType pulumi.StringInput `pulumi:"contentType"`
	Metadata pulumi.MapInput `pulumi:"metadata"`
	Name pulumi.StringInput `pulumi:"name"`
	Parallelism pulumi.IntInput `pulumi:"parallelism"`
	ResourceGroupName pulumi.StringInput `pulumi:"resourceGroupName"`
	Size pulumi.IntInput `pulumi:"size"`
	Content pulumi.ArchiveInput `pulumi:"content"`
	SourceContent pulumi.StringInput `pulumi:"sourceContent"`
	SourceUri pulumi.StringInput `pulumi:"sourceUri"`
	StorageAccountName pulumi.StringInput `pulumi:"storageAccountName"`
	StorageContainerName pulumi.StringInput `pulumi:"storageContainerName"`
	Type pulumi.StringInput `pulumi:"type"`
}
