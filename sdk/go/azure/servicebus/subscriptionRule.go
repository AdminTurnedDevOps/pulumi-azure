// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package servicebus

import (
	"context"
	"reflect"
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Manages a ServiceBus Subscription Rule.
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/website/docs/r/servicebus_subscription_rule.html.markdown.
type SubscriptionRule struct {
	pulumi.CustomResourceState

	// Represents set of actions written in SQL language-based syntax that is performed against a BrokeredMessage.
	Action pulumi.StringOutput `pulumi:"action"`

	// A `correlationFilter` block as documented below to be evaluated against a BrokeredMessage. Required when `filterType` is set to `CorrelationFilter`.
	CorrelationFilter SubscriptionRuleCorrelationFilterOutput `pulumi:"correlationFilter"`

	// Type of filter to be applied to a BrokeredMessage. Possible values are `SqlFilter` and `CorrelationFilter`.
	FilterType pulumi.StringOutput `pulumi:"filterType"`

	// Specifies the name of the ServiceBus Subscription Rule. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`

	// The name of the ServiceBus Namespace in which the ServiceBus Topic exists. Changing this forces a new resource to be created.
	NamespaceName pulumi.StringOutput `pulumi:"namespaceName"`

	// The name of the resource group in the ServiceBus Namespace exists. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`

	// Represents a filter written in SQL language-based syntax that to be evaluated against a BrokeredMessage. Required when `filterType` is set to `SqlFilter`.
	SqlFilter pulumi.StringOutput `pulumi:"sqlFilter"`

	// The name of the ServiceBus Subscription in which this Rule should be created. Changing this forces a new resource to be created.
	SubscriptionName pulumi.StringOutput `pulumi:"subscriptionName"`

	// The name of the ServiceBus Topic in which the ServiceBus Subscription exists. Changing this forces a new resource to be created.
	TopicName pulumi.StringOutput `pulumi:"topicName"`
}

// NewSubscriptionRule registers a new resource with the given unique name, arguments, and options.
func NewSubscriptionRule(ctx *pulumi.Context,
	name string, args *SubscriptionRuleArgs, opts ...pulumi.ResourceOption) (*SubscriptionRule, error) {
	if args == nil || args.FilterType == nil {
		return nil, errors.New("missing required argument 'FilterType'")
	}
	if args == nil || args.NamespaceName == nil {
		return nil, errors.New("missing required argument 'NamespaceName'")
	}
	if args == nil || args.ResourceGroupName == nil {
		return nil, errors.New("missing required argument 'ResourceGroupName'")
	}
	if args == nil || args.SubscriptionName == nil {
		return nil, errors.New("missing required argument 'SubscriptionName'")
	}
	if args == nil || args.TopicName == nil {
		return nil, errors.New("missing required argument 'TopicName'")
	}
	inputs := map[string]pulumi.Input{}
	if args != nil {
		if i := args.Action; i != nil { inputs["action"] = i.ToStringOutput() }
		if i := args.CorrelationFilter; i != nil { inputs["correlationFilter"] = i.ToSubscriptionRuleCorrelationFilterOutput() }
		if i := args.FilterType; i != nil { inputs["filterType"] = i.ToStringOutput() }
		if i := args.Name; i != nil { inputs["name"] = i.ToStringOutput() }
		if i := args.NamespaceName; i != nil { inputs["namespaceName"] = i.ToStringOutput() }
		if i := args.ResourceGroupName; i != nil { inputs["resourceGroupName"] = i.ToStringOutput() }
		if i := args.SqlFilter; i != nil { inputs["sqlFilter"] = i.ToStringOutput() }
		if i := args.SubscriptionName; i != nil { inputs["subscriptionName"] = i.ToStringOutput() }
		if i := args.TopicName; i != nil { inputs["topicName"] = i.ToStringOutput() }
	}
	var resource SubscriptionRule
	err := ctx.RegisterResource("azure:servicebus/subscriptionRule:SubscriptionRule", name, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSubscriptionRule gets an existing SubscriptionRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSubscriptionRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SubscriptionRuleState, opts ...pulumi.ResourceOption) (*SubscriptionRule, error) {
	inputs := map[string]pulumi.Input{}
	if state != nil {
		if i := state.Action; i != nil { inputs["action"] = i.ToStringOutput() }
		if i := state.CorrelationFilter; i != nil { inputs["correlationFilter"] = i.ToSubscriptionRuleCorrelationFilterOutput() }
		if i := state.FilterType; i != nil { inputs["filterType"] = i.ToStringOutput() }
		if i := state.Name; i != nil { inputs["name"] = i.ToStringOutput() }
		if i := state.NamespaceName; i != nil { inputs["namespaceName"] = i.ToStringOutput() }
		if i := state.ResourceGroupName; i != nil { inputs["resourceGroupName"] = i.ToStringOutput() }
		if i := state.SqlFilter; i != nil { inputs["sqlFilter"] = i.ToStringOutput() }
		if i := state.SubscriptionName; i != nil { inputs["subscriptionName"] = i.ToStringOutput() }
		if i := state.TopicName; i != nil { inputs["topicName"] = i.ToStringOutput() }
	}
	var resource SubscriptionRule
	err := ctx.ReadResource("azure:servicebus/subscriptionRule:SubscriptionRule", name, id, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SubscriptionRule resources.
type SubscriptionRuleState struct {
	// Represents set of actions written in SQL language-based syntax that is performed against a BrokeredMessage.
	Action pulumi.StringInput `pulumi:"action"`
	// A `correlationFilter` block as documented below to be evaluated against a BrokeredMessage. Required when `filterType` is set to `CorrelationFilter`.
	CorrelationFilter SubscriptionRuleCorrelationFilterInput `pulumi:"correlationFilter"`
	// Type of filter to be applied to a BrokeredMessage. Possible values are `SqlFilter` and `CorrelationFilter`.
	FilterType pulumi.StringInput `pulumi:"filterType"`
	// Specifies the name of the ServiceBus Subscription Rule. Changing this forces a new resource to be created.
	Name pulumi.StringInput `pulumi:"name"`
	// The name of the ServiceBus Namespace in which the ServiceBus Topic exists. Changing this forces a new resource to be created.
	NamespaceName pulumi.StringInput `pulumi:"namespaceName"`
	// The name of the resource group in the ServiceBus Namespace exists. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringInput `pulumi:"resourceGroupName"`
	// Represents a filter written in SQL language-based syntax that to be evaluated against a BrokeredMessage. Required when `filterType` is set to `SqlFilter`.
	SqlFilter pulumi.StringInput `pulumi:"sqlFilter"`
	// The name of the ServiceBus Subscription in which this Rule should be created. Changing this forces a new resource to be created.
	SubscriptionName pulumi.StringInput `pulumi:"subscriptionName"`
	// The name of the ServiceBus Topic in which the ServiceBus Subscription exists. Changing this forces a new resource to be created.
	TopicName pulumi.StringInput `pulumi:"topicName"`
}

// The set of arguments for constructing a SubscriptionRule resource.
type SubscriptionRuleArgs struct {
	// Represents set of actions written in SQL language-based syntax that is performed against a BrokeredMessage.
	Action pulumi.StringInput `pulumi:"action"`
	// A `correlationFilter` block as documented below to be evaluated against a BrokeredMessage. Required when `filterType` is set to `CorrelationFilter`.
	CorrelationFilter SubscriptionRuleCorrelationFilterInput `pulumi:"correlationFilter"`
	// Type of filter to be applied to a BrokeredMessage. Possible values are `SqlFilter` and `CorrelationFilter`.
	FilterType pulumi.StringInput `pulumi:"filterType"`
	// Specifies the name of the ServiceBus Subscription Rule. Changing this forces a new resource to be created.
	Name pulumi.StringInput `pulumi:"name"`
	// The name of the ServiceBus Namespace in which the ServiceBus Topic exists. Changing this forces a new resource to be created.
	NamespaceName pulumi.StringInput `pulumi:"namespaceName"`
	// The name of the resource group in the ServiceBus Namespace exists. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringInput `pulumi:"resourceGroupName"`
	// Represents a filter written in SQL language-based syntax that to be evaluated against a BrokeredMessage. Required when `filterType` is set to `SqlFilter`.
	SqlFilter pulumi.StringInput `pulumi:"sqlFilter"`
	// The name of the ServiceBus Subscription in which this Rule should be created. Changing this forces a new resource to be created.
	SubscriptionName pulumi.StringInput `pulumi:"subscriptionName"`
	// The name of the ServiceBus Topic in which the ServiceBus Subscription exists. Changing this forces a new resource to be created.
	TopicName pulumi.StringInput `pulumi:"topicName"`
}
type SubscriptionRuleCorrelationFilter struct {
	// Content type of the message.
	ContentType *string `pulumi:"contentType"`
	// Identifier of the correlation.
	CorrelationId *string `pulumi:"correlationId"`
	// Application specific label.
	Label *string `pulumi:"label"`
	// Identifier of the message.
	MessageId *string `pulumi:"messageId"`
	// Address of the queue to reply to.
	ReplyTo *string `pulumi:"replyTo"`
	// Session identifier to reply to.
	ReplyToSessionId *string `pulumi:"replyToSessionId"`
	// Session identifier.
	SessionId *string `pulumi:"sessionId"`
	// Address to send to.
	To *string `pulumi:"to"`
}
var subscriptionRuleCorrelationFilterType = reflect.TypeOf((*SubscriptionRuleCorrelationFilter)(nil)).Elem()

type SubscriptionRuleCorrelationFilterInput interface {
	pulumi.Input

	ToSubscriptionRuleCorrelationFilterOutput() SubscriptionRuleCorrelationFilterOutput
	ToSubscriptionRuleCorrelationFilterOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterOutput
}

type SubscriptionRuleCorrelationFilterArgs struct {
	// Content type of the message.
	ContentType pulumi.StringInput `pulumi:"contentType"`
	// Identifier of the correlation.
	CorrelationId pulumi.StringInput `pulumi:"correlationId"`
	// Application specific label.
	Label pulumi.StringInput `pulumi:"label"`
	// Identifier of the message.
	MessageId pulumi.StringInput `pulumi:"messageId"`
	// Address of the queue to reply to.
	ReplyTo pulumi.StringInput `pulumi:"replyTo"`
	// Session identifier to reply to.
	ReplyToSessionId pulumi.StringInput `pulumi:"replyToSessionId"`
	// Session identifier.
	SessionId pulumi.StringInput `pulumi:"sessionId"`
	// Address to send to.
	To pulumi.StringInput `pulumi:"to"`
}

func (SubscriptionRuleCorrelationFilterArgs) ElementType() reflect.Type {
	return subscriptionRuleCorrelationFilterType
}

func (a SubscriptionRuleCorrelationFilterArgs) ToSubscriptionRuleCorrelationFilterOutput() SubscriptionRuleCorrelationFilterOutput {
	return pulumi.ToOutput(a).(SubscriptionRuleCorrelationFilterOutput)
}

func (a SubscriptionRuleCorrelationFilterArgs) ToSubscriptionRuleCorrelationFilterOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterOutput {
	return pulumi.ToOutputWithContext(ctx, a).(SubscriptionRuleCorrelationFilterOutput)
}

type SubscriptionRuleCorrelationFilterOutput struct { *pulumi.OutputState }

// Content type of the message.
func (o SubscriptionRuleCorrelationFilterOutput) ContentType() pulumi.StringOutput {
	return o.Apply(func(v SubscriptionRuleCorrelationFilter) string {
		if v.ContentType == nil { return *new(string) } else { return *v.ContentType }
	}).(pulumi.StringOutput)
}

// Identifier of the correlation.
func (o SubscriptionRuleCorrelationFilterOutput) CorrelationId() pulumi.StringOutput {
	return o.Apply(func(v SubscriptionRuleCorrelationFilter) string {
		if v.CorrelationId == nil { return *new(string) } else { return *v.CorrelationId }
	}).(pulumi.StringOutput)
}

// Application specific label.
func (o SubscriptionRuleCorrelationFilterOutput) Label() pulumi.StringOutput {
	return o.Apply(func(v SubscriptionRuleCorrelationFilter) string {
		if v.Label == nil { return *new(string) } else { return *v.Label }
	}).(pulumi.StringOutput)
}

// Identifier of the message.
func (o SubscriptionRuleCorrelationFilterOutput) MessageId() pulumi.StringOutput {
	return o.Apply(func(v SubscriptionRuleCorrelationFilter) string {
		if v.MessageId == nil { return *new(string) } else { return *v.MessageId }
	}).(pulumi.StringOutput)
}

// Address of the queue to reply to.
func (o SubscriptionRuleCorrelationFilterOutput) ReplyTo() pulumi.StringOutput {
	return o.Apply(func(v SubscriptionRuleCorrelationFilter) string {
		if v.ReplyTo == nil { return *new(string) } else { return *v.ReplyTo }
	}).(pulumi.StringOutput)
}

// Session identifier to reply to.
func (o SubscriptionRuleCorrelationFilterOutput) ReplyToSessionId() pulumi.StringOutput {
	return o.Apply(func(v SubscriptionRuleCorrelationFilter) string {
		if v.ReplyToSessionId == nil { return *new(string) } else { return *v.ReplyToSessionId }
	}).(pulumi.StringOutput)
}

// Session identifier.
func (o SubscriptionRuleCorrelationFilterOutput) SessionId() pulumi.StringOutput {
	return o.Apply(func(v SubscriptionRuleCorrelationFilter) string {
		if v.SessionId == nil { return *new(string) } else { return *v.SessionId }
	}).(pulumi.StringOutput)
}

// Address to send to.
func (o SubscriptionRuleCorrelationFilterOutput) To() pulumi.StringOutput {
	return o.Apply(func(v SubscriptionRuleCorrelationFilter) string {
		if v.To == nil { return *new(string) } else { return *v.To }
	}).(pulumi.StringOutput)
}

func (SubscriptionRuleCorrelationFilterOutput) ElementType() reflect.Type {
	return subscriptionRuleCorrelationFilterType
}

func (o SubscriptionRuleCorrelationFilterOutput) ToSubscriptionRuleCorrelationFilterOutput() SubscriptionRuleCorrelationFilterOutput {
	return o
}

func (o SubscriptionRuleCorrelationFilterOutput) ToSubscriptionRuleCorrelationFilterOutputWithContext(ctx context.Context) SubscriptionRuleCorrelationFilterOutput {
	return o
}

func init() { pulumi.RegisterOutputType(SubscriptionRuleCorrelationFilterOutput{}) }

