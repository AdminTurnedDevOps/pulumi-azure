// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package network

import (
	"context"
	"reflect"
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Manages an ExpressRoute circuit.
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/website/docs/r/express_route_circuit.html.markdown.
type ExpressRouteCircuit struct {
	pulumi.CustomResourceState

	// Allow the circuit to interact with classic (RDFE) resources. The default value is `false`.
	AllowClassicOperations pulumi.BoolOutput `pulumi:"allowClassicOperations"`

	// The bandwidth in Mbps of the circuit being created.
	BandwidthInMbps pulumi.IntOutput `pulumi:"bandwidthInMbps"`

	// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
	Location pulumi.StringOutput `pulumi:"location"`

	// The name of the ExpressRoute circuit. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`

	// The name of the peering location and **not** the Azure resource location.
	PeeringLocation pulumi.StringOutput `pulumi:"peeringLocation"`

	// The name of the resource group in which to create the ExpressRoute circuit. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`

	// The string needed by the service provider to provision the ExpressRoute circuit.
	ServiceKey pulumi.StringOutput `pulumi:"serviceKey"`

	// The name of the ExpressRoute Service Provider.
	ServiceProviderName pulumi.StringOutput `pulumi:"serviceProviderName"`

	// The ExpressRoute circuit provisioning state from your chosen service provider. Possible values are "NotProvisioned", "Provisioning", "Provisioned", and "Deprovisioning".
	ServiceProviderProvisioningState pulumi.StringOutput `pulumi:"serviceProviderProvisioningState"`

	// A `sku` block for the ExpressRoute circuit as documented below.
	Sku ExpressRouteCircuitSkuOutput `pulumi:"sku"`

	// A mapping of tags to assign to the resource.
	Tags pulumi.MapOutput `pulumi:"tags"`
}

// NewExpressRouteCircuit registers a new resource with the given unique name, arguments, and options.
func NewExpressRouteCircuit(ctx *pulumi.Context,
	name string, args *ExpressRouteCircuitArgs, opts ...pulumi.ResourceOption) (*ExpressRouteCircuit, error) {
	if args == nil || args.BandwidthInMbps == nil {
		return nil, errors.New("missing required argument 'BandwidthInMbps'")
	}
	if args == nil || args.PeeringLocation == nil {
		return nil, errors.New("missing required argument 'PeeringLocation'")
	}
	if args == nil || args.ResourceGroupName == nil {
		return nil, errors.New("missing required argument 'ResourceGroupName'")
	}
	if args == nil || args.ServiceProviderName == nil {
		return nil, errors.New("missing required argument 'ServiceProviderName'")
	}
	if args == nil || args.Sku == nil {
		return nil, errors.New("missing required argument 'Sku'")
	}
	inputs := map[string]pulumi.Input{}
	if args != nil {
		if i := args.AllowClassicOperations; i != nil { inputs["allowClassicOperations"] = i.ToBoolOutput() }
		if i := args.BandwidthInMbps; i != nil { inputs["bandwidthInMbps"] = i.ToIntOutput() }
		if i := args.Location; i != nil { inputs["location"] = i.ToStringOutput() }
		if i := args.Name; i != nil { inputs["name"] = i.ToStringOutput() }
		if i := args.PeeringLocation; i != nil { inputs["peeringLocation"] = i.ToStringOutput() }
		if i := args.ResourceGroupName; i != nil { inputs["resourceGroupName"] = i.ToStringOutput() }
		if i := args.ServiceProviderName; i != nil { inputs["serviceProviderName"] = i.ToStringOutput() }
		if i := args.Sku; i != nil { inputs["sku"] = i.ToExpressRouteCircuitSkuOutput() }
		if i := args.Tags; i != nil { inputs["tags"] = i.ToMapOutput() }
	}
	var resource ExpressRouteCircuit
	err := ctx.RegisterResource("azure:network/expressRouteCircuit:ExpressRouteCircuit", name, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetExpressRouteCircuit gets an existing ExpressRouteCircuit resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetExpressRouteCircuit(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ExpressRouteCircuitState, opts ...pulumi.ResourceOption) (*ExpressRouteCircuit, error) {
	inputs := map[string]pulumi.Input{}
	if state != nil {
		if i := state.AllowClassicOperations; i != nil { inputs["allowClassicOperations"] = i.ToBoolOutput() }
		if i := state.BandwidthInMbps; i != nil { inputs["bandwidthInMbps"] = i.ToIntOutput() }
		if i := state.Location; i != nil { inputs["location"] = i.ToStringOutput() }
		if i := state.Name; i != nil { inputs["name"] = i.ToStringOutput() }
		if i := state.PeeringLocation; i != nil { inputs["peeringLocation"] = i.ToStringOutput() }
		if i := state.ResourceGroupName; i != nil { inputs["resourceGroupName"] = i.ToStringOutput() }
		if i := state.ServiceKey; i != nil { inputs["serviceKey"] = i.ToStringOutput() }
		if i := state.ServiceProviderName; i != nil { inputs["serviceProviderName"] = i.ToStringOutput() }
		if i := state.ServiceProviderProvisioningState; i != nil { inputs["serviceProviderProvisioningState"] = i.ToStringOutput() }
		if i := state.Sku; i != nil { inputs["sku"] = i.ToExpressRouteCircuitSkuOutput() }
		if i := state.Tags; i != nil { inputs["tags"] = i.ToMapOutput() }
	}
	var resource ExpressRouteCircuit
	err := ctx.ReadResource("azure:network/expressRouteCircuit:ExpressRouteCircuit", name, id, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ExpressRouteCircuit resources.
type ExpressRouteCircuitState struct {
	// Allow the circuit to interact with classic (RDFE) resources. The default value is `false`.
	AllowClassicOperations pulumi.BoolInput `pulumi:"allowClassicOperations"`
	// The bandwidth in Mbps of the circuit being created.
	BandwidthInMbps pulumi.IntInput `pulumi:"bandwidthInMbps"`
	// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
	Location pulumi.StringInput `pulumi:"location"`
	// The name of the ExpressRoute circuit. Changing this forces a new resource to be created.
	Name pulumi.StringInput `pulumi:"name"`
	// The name of the peering location and **not** the Azure resource location.
	PeeringLocation pulumi.StringInput `pulumi:"peeringLocation"`
	// The name of the resource group in which to create the ExpressRoute circuit. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringInput `pulumi:"resourceGroupName"`
	// The string needed by the service provider to provision the ExpressRoute circuit.
	ServiceKey pulumi.StringInput `pulumi:"serviceKey"`
	// The name of the ExpressRoute Service Provider.
	ServiceProviderName pulumi.StringInput `pulumi:"serviceProviderName"`
	// The ExpressRoute circuit provisioning state from your chosen service provider. Possible values are "NotProvisioned", "Provisioning", "Provisioned", and "Deprovisioning".
	ServiceProviderProvisioningState pulumi.StringInput `pulumi:"serviceProviderProvisioningState"`
	// A `sku` block for the ExpressRoute circuit as documented below.
	Sku ExpressRouteCircuitSkuInput `pulumi:"sku"`
	// A mapping of tags to assign to the resource.
	Tags pulumi.MapInput `pulumi:"tags"`
}

// The set of arguments for constructing a ExpressRouteCircuit resource.
type ExpressRouteCircuitArgs struct {
	// Allow the circuit to interact with classic (RDFE) resources. The default value is `false`.
	AllowClassicOperations pulumi.BoolInput `pulumi:"allowClassicOperations"`
	// The bandwidth in Mbps of the circuit being created.
	BandwidthInMbps pulumi.IntInput `pulumi:"bandwidthInMbps"`
	// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
	Location pulumi.StringInput `pulumi:"location"`
	// The name of the ExpressRoute circuit. Changing this forces a new resource to be created.
	Name pulumi.StringInput `pulumi:"name"`
	// The name of the peering location and **not** the Azure resource location.
	PeeringLocation pulumi.StringInput `pulumi:"peeringLocation"`
	// The name of the resource group in which to create the ExpressRoute circuit. Changing this forces a new resource to be created.
	ResourceGroupName pulumi.StringInput `pulumi:"resourceGroupName"`
	// The name of the ExpressRoute Service Provider.
	ServiceProviderName pulumi.StringInput `pulumi:"serviceProviderName"`
	// A `sku` block for the ExpressRoute circuit as documented below.
	Sku ExpressRouteCircuitSkuInput `pulumi:"sku"`
	// A mapping of tags to assign to the resource.
	Tags pulumi.MapInput `pulumi:"tags"`
}
type ExpressRouteCircuitSku struct {
	// The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
	Family string `pulumi:"family"`
	// The service tier. Possible values are `Standard` or `Premium`.
	Tier string `pulumi:"tier"`
}
var expressRouteCircuitSkuType = reflect.TypeOf((*ExpressRouteCircuitSku)(nil)).Elem()

type ExpressRouteCircuitSkuInput interface {
	pulumi.Input

	ToExpressRouteCircuitSkuOutput() ExpressRouteCircuitSkuOutput
	ToExpressRouteCircuitSkuOutputWithContext(ctx context.Context) ExpressRouteCircuitSkuOutput
}

type ExpressRouteCircuitSkuArgs struct {
	// The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
	Family pulumi.StringInput `pulumi:"family"`
	// The service tier. Possible values are `Standard` or `Premium`.
	Tier pulumi.StringInput `pulumi:"tier"`
}

func (ExpressRouteCircuitSkuArgs) ElementType() reflect.Type {
	return expressRouteCircuitSkuType
}

func (a ExpressRouteCircuitSkuArgs) ToExpressRouteCircuitSkuOutput() ExpressRouteCircuitSkuOutput {
	return pulumi.ToOutput(a).(ExpressRouteCircuitSkuOutput)
}

func (a ExpressRouteCircuitSkuArgs) ToExpressRouteCircuitSkuOutputWithContext(ctx context.Context) ExpressRouteCircuitSkuOutput {
	return pulumi.ToOutputWithContext(ctx, a).(ExpressRouteCircuitSkuOutput)
}

type ExpressRouteCircuitSkuOutput struct { *pulumi.OutputState }

// The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
func (o ExpressRouteCircuitSkuOutput) Family() pulumi.StringOutput {
	return o.Apply(func(v ExpressRouteCircuitSku) string {
		return v.Family
	}).(pulumi.StringOutput)
}

// The service tier. Possible values are `Standard` or `Premium`.
func (o ExpressRouteCircuitSkuOutput) Tier() pulumi.StringOutput {
	return o.Apply(func(v ExpressRouteCircuitSku) string {
		return v.Tier
	}).(pulumi.StringOutput)
}

func (ExpressRouteCircuitSkuOutput) ElementType() reflect.Type {
	return expressRouteCircuitSkuType
}

func (o ExpressRouteCircuitSkuOutput) ToExpressRouteCircuitSkuOutput() ExpressRouteCircuitSkuOutput {
	return o
}

func (o ExpressRouteCircuitSkuOutput) ToExpressRouteCircuitSkuOutputWithContext(ctx context.Context) ExpressRouteCircuitSkuOutput {
	return o
}

func init() { pulumi.RegisterOutputType(ExpressRouteCircuitSkuOutput{}) }

